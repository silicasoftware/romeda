<script type="text/javascript">
        var gk_isXlsx = false;
        var gk_xlsxFileLookup = {};
        var gk_fileData = {};
        function filledCell(cell) {
          return cell !== '' && cell != null;
        }
        function loadFileData(filename) {
        if (gk_isXlsx && gk_xlsxFileLookup[filename]) {
            try {
                var workbook = XLSX.read(gk_fileData[filename], { type: 'base64' });
                var firstSheetName = workbook.SheetNames[0];
                var worksheet = workbook.Sheets[firstSheetName];

                // Convert sheet to JSON to filter blank rows
                var jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1, blankrows: false, defval: '' });
                // Filter out blank rows (rows where all cells are empty, null, or undefined)
                var filteredData = jsonData.filter(row => row.some(filledCell));

                // Heuristic to find the header row by ignoring rows with fewer filled cells than the next row
                var headerRowIndex = filteredData.findIndex((row, index) =>
                  row.filter(filledCell).length >= filteredData[index + 1]?.filter(filledCell).length
                );
                // Fallback
                if (headerRowIndex === -1 || headerRowIndex > 25) {
                  headerRowIndex = 0;
                }

                // Convert filtered JSON back to CSV
                var csv = XLSX.utils.aoa_to_sheet(filteredData.slice(headerRowIndex)); // Create a new sheet from filtered array of arrays
                csv = XLSX.utils.sheet_to_csv(csv, { header: 1 });
                return csv;
            } catch (e) {
                console.error(e);
                return "";
            }
        }
        return gk_fileData[filename] || "";
        }
        </script><!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <div style="text-align:center; margin-bottom:20px;">
    <img src="img/banner.png" alt="Andromeda Banner" style="max-width:100%; height:auto; border-radius:10px;">
  </div>

  <title>Andromeda.h Macro Reference Library</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      line-height: 1.6;
      margin: 0 auto;
      max-width: 800px;
      padding: 20px;
    }
    .download-button {
      display: inline-block;
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      text-decoration: none;
      border-radius: 5px;
      margin: 10px 0;
    }
    .download-button:hover {
      background-color: #0056b3;
    }
    pre code {
      display: block;
      background-color: #f4f4f4;
      border: 1px solid #ddd;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      overflow-x: auto;
    }
    h2, h3 {
      color: #333;
    }
    ol {
      padding-left: 20px;
    }
  </style>
</head>
<body>
  <h1>Andromeda.h — Macro Reference</h1>

  <p>A domain-specific macro layer over C++ for fast prototyping of I/O, flow control, and mini-scripts.</p>

  <p><a href="https://mega.nz/folder/O4xgQAjb#xdg2l8ufvoEUOOhkgmBsOg" class="download-button">⬇ Download Library</a></p>

  <h2>Contents</h2>
  <ol>
    <li><a href="#include-directive">Include Directive</a></li>
    <li><a href="#program-entry">Program Entry</a></li>
    <li><a href="#io">I/O</a></li>
    <li><a href="#variables">Variables</a></li>
    <li><a href="#functions-scripts">Functions & Scripts</a></li>
    <li><a href="#pointers-memory">Pointers & Memory</a></li>
    <li><a href="#control-flow">Control Flow</a></li>
    <li><a href="#loops">Loops</a></li>
    <li><a href="#math-helpers">Math Helpers</a></li>
    <li><a href="#logic-gates">Logic Gates</a></li>
    <li><a href="#structs-classes-enums">Structs / Classes / Enums</a></li>
    <li><a href="#namespaces">Namespaces</a></li>
    <li><a href="#vectors">Vectors (int aliases)</a></li>
    <li><a href="#flags">Flags</a></li>
    <li><a href="#misc">Misc</a></li>
    <li><a href="#notes-caveats">Notes & Caveats</a></li>
  </ol>

  <h2 id="include-directive">1. Include Directive</h2>
  <p>Include the Andromeda library to use its macros.</p>
  <pre><code>#include "andromeda/include/andromeda.h"
  </code></pre>
  <p>// Note: Ensure the path to andromeda.h matches your project structure.</p>

  <h2 id="program-entry">2. Program Entry</h2>
  <p>Aliases for int main() { ... }.</p>
  <pre><code>#define MAIN(code)   int main(){code}
#define START(code)  int main(){code}
#define BEGIN(code)  int main(){code}
#define PLAY(code)   int main(){code}
#define LAUNCH(code) int main(){code}
#define _(data)      int main(){data}
  </code></pre>
  <p>// Example</p>
  <pre><code>MAIN(print("Hello"))
PLAY(print("Game Started"))
  </code></pre>

  <h2 id="io">3. Input / Output</h2>
  <h3>Output</h3>
  <pre><code>#define cout_start std::cout <<
#define cout_insrt <<
#define cout_end   << std::endl;
#define print(x)   std::cout << x << std::endl;
#define output(prefix, data, isEnable) \
  if(isEnable){ std::cout << prefix; } \
  std::cout << data << std::endl;
#define say   std::cout << "Andromeda: Hello World!" << std::endl;
#define ping  std::cout << "Hello World!" << std::endl;
#define pulse std::cout << "Hello World!" << std::endl; return 1; // ends main
#define _p    std::cout << "Hello World!" << std::endl;
  </code></pre>
  <p>// Examples</p>
  <pre><code>cout_start "Value: " cout_insrt 42 cout_end
output("x = ", 13, true)
  </code></pre>
  <h3>Input</h3>
  <pre><code>#define cin_start std::cin >>
#define cin_insrt >>
#define cin_end   ;
#define input(var, prefix, isEnable) \
  if(isEnable){ std::cout << prefix; } \
  std::cin >> var;
  </code></pre>
  <p>// Example</p>
  <pre><code>int age; input(age, "Enter age: ", true)
  </code></pre>

  <h2 id="variables">4. Variables</h2>
  <p>Convenience macros for declarations.</p>
  <pre><code>#define var(name, value)        auto name = value;
#define str(name, value)        std::string name = value;
#define string(name, value)     std::string name = value;
#define int(name, value)        int name = value;
#define integral(name, value)   int name = value;
#define doub(name, value)       double name = value;
#define double(name, value)     double name = value;
#define f(name, value)          float name = value;
#define float(name, value)      float name = value;
#define char(name, value)       char name = value;
#define character(name, value)  char name = value;
#define bool(name, value)       bool name = value;
#define boolean(name, value)    bool name = value;
#define variable(T, name, val)  T name = val;
#define VAR(T, name)            T name;
  </code></pre>
  <p>// Examples</p>
  <pre><code>str(title, "Andromeda")
int(counter, 10)
doub(pi, 3.14159)
  </code></pre>

  <h2 id="functions-scripts">5. Functions & Scripts</h2>
  <pre><code>#define define(name, body)             void name(){ body };
#define create(name)                   void name();
#define define2(name, body, param)     void name(param){ body };
#define run(fn)                        fn();
#define run2(fn, arg)                  fn(arg);
#define script(body)                   body;
  </code></pre>
  <p>// Examples</p>
  <pre><code>define(hello, print("Hello!"))
run(hello)

define2(square, print(x * x), int x)
run2(square, 5)
  </code></pre>

  <h2 id="pointers-memory">6. Pointers & Memory</h2>
  <pre><code>#define pointer(alias, var)    auto *alias = &var
#define address(x)             &x
#define data(ptr)              *ptr
#define p(pptr)                **pptr
#define deference(a, b)        a = *(b)
#define pointerchange(a, b)    *a b   // raw text substitution
  </code></pre>
  <p>// Example</p>
  <pre><code>int x = 5; pointer(px, x); print(data(px)) // 5
  </code></pre>

  <h2 id="control-flow">7. Control Flow</h2>
  <pre><code>#define index(i, code)        case i: code break;
#define indexer(expr, cases)  switch(expr){ cases }
#define loop(cond, body)      while(cond){ body }
#define iftrue(cond, then)    if(cond){ then }
#define iffalse(cond, then)   if(cond){ then } // identical to iftrue
#define branch(cond, t, f)    if(cond){ t } else { f }
  </code></pre>
  <p>// Example</p>
  <pre><code>int which = 2;
indexer(which,
  index(1, print("one"))
  index(2, print("two"))
)
  </code></pre>

  <h2 id="loops">8. Loops</h2>
  <pre><code>#define forplus(min, max, body)         for(int i = min; i <= max; i++){ body }
#define forsub(max, min, body)          for(int i = max; i <= min; i--){ body }
#define forloop(out, min, max, body)    for(int i = min; i <= max; i++){ body if(out){ std::cout << i << std::endl; }}
#define loopforward(out, min, max, b)   for(int i = min; i <= max; i++){ b if(out){ std::cout << i << std::endl; }}
#define loopbackward(out, max, min, b)  for (int i = 10; i >= 0; i--){ b if(out){ std::cout << i << std::endl; }}
  </code></pre>

  <h2 id="math-helpers">9. Math Helpers</h2>
  <pre><code>#define add2(a,b)  ((a) + (b))
#define add3(a,b,c) ((a) + (b) + (c))
#define add4(a,b,c,d) ((a) + (b) + (c) + (d))
#define sub2(a,b)  ((a) - (b))
#define sub3(a,b,c) ((a) - (b) - (c))
#define sub4(a,b,c,d) ((a) - (b) - (c) - (d))
#define multi2(a,b) ((a) * (b))
#define multi3(a,b,c) ((a) * (b) + (c))
#define multi4(a,b,c,d) ((a) * (b) * (c) * (d))
#define div2(a,b)   ((a) / (b))
#define div3(a,b,c) ((a) / (b) + (c))
#define div4(a,b,c,d) ((a) / (b) / (c) / (d))
#define add(loops,a,b)   (loops * (a + b))
#define sub(loops,a,b)   ((a) - (b) * (loops))
#define multi(loops,a,b) ((a) * (b) * loops)
#define div(loops,a,b)   ((a) / (b) * (loops))
  </code></pre>
  <p>Note: multi3/multi4 and div3/div4 Math matrixs only support up to 4!</p>

  <h2 id="logic-gates">10. Logic Gates</h2>
  <pre><code>#define not(a,b)     ((b) = !(a))
#define nor(a,b,c)   ((c) = !(a || b))
#define and(a,b,c)   ((c) = (a && b))
#define or(a,b,c)    ((c) = (a || b))
#define nand(a,b,c)  ((c) = !(a && b))
#define xor(a,b,c)   ((c) = (a ^ b))
#define xnor(a,b,c)  ((c) = !(a ^ b))
#define buffer(a,b)  ((b) = (a))
  </code></pre>

  <h2 id="structs-classes-enums">11. Structs, Classes, Enums</h2>
  <pre><code>#define class(name, pub, priv) class name { public: pub private: priv; };
#define struct(name, body)     struct name { body };
#define enum(name, body)       enum name { body };
#define enum2(name,a,b)        enum name { a, b };
#define enum3(name,a,b,c)      enum name { a, b, c };
#define enum4(name,a,b,c,d)    enum name { a, b, c, d };
// ... up to enum10 (typo in original: "emum")
  </code></pre>
  <p>Andromeda only supports enums of 10 max!</p>

  <h2 id="namespaces">12. Namespace Helpers</h2>
  <pre><code>#define close(name, body)    namespace name { body }
#define use(space, sym)      space::sym
#define steal(ns, sym, val)  ns::sym = val
#define nest(ns, sym, val)   ns::sym = auto val // nonsensical as-is
  </code></pre>

  <h2 id="vectors">13. Vectors (simple int fields)</h2>
  <pre><code>#define vector(x)            int x;
#define vector2(x,y)         int x, y;
#define vector3(x,y,z)       int x, y, z;
#define vector4(x,y,z,t)     int x, y, z, t;
  </code></pre>

  <h2 id="flags">14. Flags</h2>
  <pre><code>#define on true
#define off false
#define ON true
#define OFF false
#define ENABLE true
#define DISABLE false
#define enable true
#define disable false
#define ENABLED true
#define DISABLED false
#define enabled true
#define disabled false
  </code></pre>
  <p>FLAGS are good for prototyping!</p>

  <h2 id="misc">15. Miscellaneous</h2>
  <pre><code>#define container(x) x
#define END ;
#define NEXT ;
#define end return 1;
#define peek ;
#define grabbing(x) x;
#define program(x) x
#define application(name, x) x
#define main_program(name, x)     int main(){ x }
#define main_application(name, x) int main(){ x }
#define main_function(name, x)    int main(){ x }
#define flipflop(x) x = !x;
#define indexer(data, cases) switch(data){ cases }
  </code></pre>

  <h2 id="notes-caveats">Notes & Caveats</h2>
  <pre><code>	Macros are raw text substitutions—watch for side effects, precedence, and multiple evaluations.
  </code></pre>

  <p>Silica Software @2025</p>
</body>
</html>